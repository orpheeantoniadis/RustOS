\documentclass[a4paper, 12pt]{article}
\usepackage[francais]{babel}
\usepackage{fontspec}
\usepackage{enumitem}
\usepackage{authblk}
\usepackage{pdfpages}
\usepackage{minted}
\definecolor{bg}{RGB}{246,248,250}
\newminted{rust}{fontsize=\footnotesize,tabsize=4,frame=single,linenos}
\newminted{shell}{tabsize=4}
\usepackage{dirtree}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{tabularx}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{wrapfig}
\newcolumntype{C}[1]{>{\centering\arraybackslash}p{#1}}
\setlength{\parindent}{0pt}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=blue
}
\usepackage{caption}
\newenvironment{code}{\captionsetup{type=listing,skip=-10pt}}{}
\usepackage{etoolbox}
\patchcmd{\thebibliography}{\section*{\refname}}{}{}{}
\usepackage[left=2.5cm,top=2.5cm,right=2.5cm,bottom=2.5cm]{geometry}
\usepackage{glossaries}
	\let\oldnewacronym\newacronym
	\newcommand*{\provideacronym}[3]{%
	  \ifglsentryexists{#1}{%
	  }{%
	    \oldnewacronym{#1}{#2}{#3}%
	  }%
	}
\makeglossaries

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\includepdf[pages=1]{../ITI_masque_couverture.pdf}

\newpage
\thispagestyle{empty}
\clearpage\mbox{}\clearpage
\pagenumbering{arabic}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\addcontentsline{toc}{section}{Descriptif}
\includepdf[pages=1]{../ITI_MAT_jour_enonce_diplome_Antoniadis_Gluck_2018.pdf}

\newpage
\thispagestyle{empty}
\clearpage\mbox{}\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\addcontentsline{toc}{section}{Résumé}
\includepdf[pages=1]{../ITI_masque_resume_diplome_2018.pdf}

\newpage
\thispagestyle{empty}
\clearpage\mbox{}\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\setcounter{tocdepth}{2}
\addcontentsline{toc}{section}{Table des matières}
\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\addcontentsline{toc}{section}{Table des figures}
\listoffigures

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\addcontentsline{toc}{section}{Table des tables}
\renewcommand{\listtablename}{Table des tables}
\listoftables

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\addcontentsline{toc}{section}{Table des \textit{listings} de code}
\renewcommand\listoflistingscaption{Table des \textit{listings} de code}
\listoflistings

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\addcontentsline{toc}{section}{Acronymes}
\newacronym{os}{OS}{\textit{Operating System}}
\newacronym{elf}{ELF}{\textit{Executable and Linkable Format}}
\newacronym{gcc}{GCC}{\textit{GNU Compiler Collection}}
\newacronym{iso}{ISO}{\textit{International Organization for Standardization}}
\newacronym{vram}{VRAM}{\textit{Video Random Access Memory}}
\newacronym{grub}{GRUB}{\textit{GRand Unified Bootloader}}
\newacronym{bios}{BIOS}{\textit{Basic Input Output System}}
\newacronym{pc}{PC}{\textit{Personal Computer}}
\newacronym{mbr}{MBR}{\textit{Master Boot Record}}
\newacronym{gdt}{GDT}{\textit{Global Descriptor Table}}
\newacronym{idt}{IDT}{\textit{Interrupt Descriptor Table}}
\newacronym{vga}{VGA}{\textit{Video Graphics Array}}
\newacronym{pio}{PIO}{\textit{Port Input/Output}}
\newacronym{cpu}{CPU}{\textit{Central Processing Unit}}
\newacronym{IA-32}{IA-32}{\textit{Intel Architecture 32 bits}}
\newacronym{ram}{RAM}{\textit{Random Access Memory}}
\newacronym{mmu}{MMU}{\textit{Memory Management Unit}}
\newacronym{ldt}{LDT}{\textit{Local Descriptor Table}}
\newacronym{mmio}{MMIO}{\textit{Memory Mapped Input/Output}}
\newacronym{nmi}{NMI}{\textit{Non Maskable Interrupt}}
\newacronym{irq}{IRQ}{\textit{Interrupt Request}}
\newacronym{isr}{ISR}{\textit{Interrupt Service Routine}}
\newacronym{pic}{PIC}{\textit{Programmable Interrupt Controller}}
\newacronym{crtc}{CRTC}{\textit{Cathode Ray Tube Controller}}
\newacronym{pit}{PIT}{\textit{Programmable Interval Timer}}
\newacronym{tss}{TSS}{\textit{Task State Segment}}
\newacronym{fat}{FAT}{\textit{File Allocation Table}}
\newacronym{api}{API}{\textit{Application Programming Interface}}
\newacronym{posix}{POSIX}{\textit{Portable Operating System Interface}}
\newacronym{toml}{TOML}{\textit{Tom’s Obvious, Minimal Language}}
\newacronym{abi}{ABI}{\textit{Application Binary Interface}}
\newacronym{json}{JSON}{\textit{JavaScript Object Notation}}
\newacronym{nasm}{NASM}{\textit{Netwide Assembler}}
\printglossary[type=\acronymtype,title={Acronymes}]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section*{Avant-propos}
\addcontentsline{toc}{section}{Avant-propos}

\subsection*{Présentation}
Ce mémoire constitue l'aboutissement de 11 semaines de travail dans le cadre de
l'obtention du titre de Bachelor en Ingénierie des Technologies de l'Information,
orientation informatique matérielle, à hepia. Le projet consiste à implémenter
un système d'exploitation simple pour l'architecture \acrshort{IA-32} avec le langage
de programmation Rust. Ce document commence par introduire le sujet en rappelant
les objectifs et en décrivant l'architecture du système. Les caractéristiques principales
du langage Rust sont ensuite détaillées. L'implémentation du sysème d'exploitation
est expliquée en plusieurs parties. Nous nous intéressons en premier lieu à la
compilation et à l'exécution du système. Nous voyons ensuite les différentes techniques
de gestion mémoire utilisées (segmentation, pagination, allocation dynamique).
Après cela, nous nous intéressons à la manière dont un processeur Intel 32 bits
permet de communiquer avec ses périphériques (ports d'entrées/sorties, interruptions).
Le système de fichiers développé pour notre système est ensuite présenté. Enfin,
nous expliquons le fonctionnement du mode utilisateur et les différents mécanismes
permettant à une application utilisateur de communiquer avec le \textit{kernel}.
Ce rapport se termine par une présentation des résultats, une partie de discussions
au sujet des problèmes rencontrés, des améliorations possibles et des différences
entre le Rust et le C avant de conclure sur le bilan du travail accompli.

\subsection*{Conventions typographiques}
Lors de la rédaction de ce document, les conventions typographiques ci-dessous ont
été adoptées.
\begin{itemize}[label=\textbullet]
	\item Tous les mots empruntés à la langue anglaise sont écrits en \textit{italique}
	\item Toute référence à un nom de fichier (ou dossier), un chemin d’accès, une 
    utilisation de paramètre, variable, ou commande utilisable par l’utilisateur, 
    est écrite avec la police d’écriture \mintinline{rust}{Courier New}.
	\item Tout extrait de fichier ou de code est écrit selon le format suivant:
\begin{rustcode}
fn main() {
    println!("Hello, world!");
}
\end{rustcode}
    \item Toute commande importante dans le cadre du projet est écrite selon le
    format suivant:
\begin{shellcode}
$ echo Hello world!
\end{shellcode}
\end{itemize}

\subsection*{Remerciements}
J'aimerais remercier l'équipe enseignante pour la qualité de leurs enseignements,
leur implication et leur pédagogie que j'ai pu apprécier au long de ces trois
années passées à hepia. Merci à M. Glück, qui m'a suivi tout le long de ce travail
de Bachelor, pour son aide et ses conseils. Merci à ma famille et à mes proches
d'avoir été présents pendant toutes mes études. Pour finir, merci à Camille pour la
relecture de ce mémoire mais surtout pour m'avoir soutenu et supporté durant ces
11 semaines.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Introduction}
\subsection{Contexte}
Le langage C est généralement le langage utilisé dans le domaine de la programmation
système. En effet, le langage étant bas niveau (opérations bit à bit, utilisation
de pointeurs), il dispose d'une très grande rapidité d'exécution. De plus, il est
compatible avec de nombreuses architectures car il est basé sur un standard ouvert.
Ce langage souffre tout de même de nombreux problèmes. La gestion de la mémoire
est la cause de beaucoup d'entre eux. Par exemple, le dépassement de tampon
(\textit{buffer overflow}) reste une faille de sécurité encore exploitable.
Dans ce contexte, des alternatives au langage C (C++, D, Go, Rust) ont rapidement
été proposées. Le langage Rust est développé par les ingénieurs de Mozilla. Il
est décrit par ces derniers comme étant extrêmement sécurisé. Plus robuste et tout
aussi performant, il est vu par beaucoup comme le successeur du C.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Objectifs}
L'objectif principal de ce projet est d'implémenter un système d'exploitation
avec le langage Rust. Une première partie a donc été un travail de recherche
sur le langage. Le but était de comprendre le fonctionnement de Rust, ses caractéristiques
principales ainsi que ses spécificités. De plus, il a fallu étudier son utilisation
dans le cadre de la programmation système et plus précisémment dans le développement
d'un système d'exploitation \textit{bare metal}. La seconde partie a été l'implémentation
du système d'exploitation en question pour l'architecture \acrshort{IA-32}. Une étude
des sujets liés à la conception d'\acrshort{os} pour cette architecture a été faite.
Le deuxième objectif de ce projet est de comparer le langage Rust au langage C.
On a vu que le Rust est considéré comme étant le successeur du C. La programmation
d'\acrshort{os} est un bon contexte pour les comparer étant donnée qu'actuellement,
la majorité des systèmes d'exploitation sont en C. Pour résumer, ce travail de
Bachelor a suivi les étapes suivantes : \\

\begin{itemize}[label=\textbullet]
	\item Etude du langage de programmation Rust dans le cadre de la conception
    d'un système d'exploitation \textit{bare metal} 
	\item Etude des sujets liés à la conception d'un système d'exploitation pour
    l'architecture \acrshort{IA-32}
	\item Implémentation en Rust d'un système d'exploitation simple
    \item Comparaison entre le langage Rust et le langage C
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Architecture globale}
\input{architecture.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Langage Rust}
\input{rust.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Exécution du \textit{kernel}}
\input{execution.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Gestion mémoire}
\input{memory.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Périphériques}
\input{peripherals.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Système de fichiers}
\input{fs.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Tâches utilisateurs}
\input{user.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Discussions}
\subsection{Comparaison entre C et Rust}
\subsubsection{Avantages du langage Rust}
\paragraph{Sécurité} :
un avantage principal du langage Rust par rapport au langage C est son compilateur.
Beaucoup d'erreurs dans les programmes en C viennent du programmeur et du laxisme
du compilateur C. Toutes les erreurs liées à la manipulation de la mémoire sont
traitées directement à la compilation d'un programme Rust. Les variable immutables
par défaut ainsi que le concept d'\textit{ownership} oblige le programmeur à faire
un programme sécurisé au niveau de la manipulation de la mémoire.

\paragraph{Langage moderne} :
Rust étant un langage moderne, il emprunte de nombreux concepts à d'autres langages.
Les structures et les traits permettent de faire de la programmation orientée objet.
Par exemple dans notre \acrshort{os}, l'implémentation de la macro \mintinline{rust}{print!}
permettant d'afficher une chaîne de caractères formatée a été extrêment simple et
rapide. Ceci a été permis grâce au concept de trait et à la manipulation de chaînes
de caractères native à Rust.

\paragraph{Flexibilité} :
Rust est aussi beaucoup plus flexible que C. Des librairies peuvent être ajoutées
au projet directement avec Cargo et \href{https://crates.io}{Crates.io}. De plus,
Cargo permet aisément de faire des tests unitaires, de générer de la documentation
pour le code et d'exécuter un projet avec de nombreuses dépendances.

\paragraph{Rapidité} :
un dernier avantage de Rust sont ses performances. D'après le site
\href{https://benchmarksgame-team.pages.debian.net/benchmarksgame/}{Benchmarks Game},
Rust est presque aussi performant que le C \cite{ref30}. Le langage Rust arrive
donc a avoir presque les mêmes performances que le C tout en étant plus sécurisé,
plus moderne et plus flexible.

\subsubsection{Inconvénients du langage Rust}
\paragraph{Documentation} :
actuellement, un des gros inconvénients de Rust est sa documentation. Le langage
étant récent, il est difficile de trouver des exemples sur internet. Il est vrai
que l'équipe de Rust fournit des documents (livre de Rust, de Cargo, exemples, etc)
mais ceux-ci restent légèrement incomplets au sujet des fonctionnalités avancées
de Rust.

\paragraph{Taille des exécutables} :
le langage Rust offre de nombreux mécanismes de sécurité. Il est moderne et possède
beaucoup de fonctionnalités. Le problème ici est que toutes ces fonctionnalités
et mécanismes viennent augmenter la taille de l'exécutable généré par le compilateur.
Un simple programme affichant une chaîne de caractères sur la sortie standard peut
faire jusqu'à 500'000 octets alors qu'en C le même programme aurait une taille de
8000 octets. Dans le chapitre \ref{sec:user:compil}, des méthodes ont été
données pour diminuer la taille d'un exécutable. Cependant, ces méthodes suppriment
certains mécanismes de Rust. Ces problèmes font qu'il est difficile d'utiliser
Rust dans des systèmes embarqués là où C est indispensable.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\subsection{Problèmes rencontrés}
\subsubsection{Compilation de Rust}
Les plus grandes difficultés du projet ont été rencontrées pour la compilation
du Rust. Le langage et le compilateur sont bien documentés tant qu'on reste
dans de la programmation haut niveau. Il n'y a pas contre que très peu d'informations
sur les options avancées du compilateur. Un premier exemple est le contenu d'un
fichier \textit{target triple}. Toutes les options de ce fichier sont énumérées
dans la documentation de Rust mais il n'y a qu'une simple description, aucun exemple.
De plus, les systèmes d'exploitation en Rust existants sont en général pour une
architecture 64 bits. Il a donc aussi été compliqué de trouver des exemples pour
l'architecture utilisée (\acrshort{IA-32}). Un autre exemple est la compilation
d'un programme Rust en format binaire (expliquée dans la partie \ref{sec:user:compil}).
Pour rappel, afin de compiler le code Rust en fichier objet destiné à un format
binaire, il faut utiliser l'option \mintinline{text}{-C relocation_model=static}.
D'après la documentation de la structure \mintinline{text}{Target}, l'option
\mintinline{text}{relocation_model} peut être mise directement dans le
\textit{target triple} sans passer par les options du compilateur \cite{ref29}.
En réalité, l'option ne marche pas lorsqu'elle est mise dans le fichier \textit{target},
il est impératif de spécifier l'option à Xargo.

\subsubsection{Librairie \mintinline{text}{core}}
La librairie \mintinline{text}{core}, bien que très pratique pour la réalisation
de ce travail, a été la source de quelques problèmes. Cette librairie constitue
la base de Rust. Sans cette librairie il ne serait même pas possible de faire une
addition avec l'opérateur '\mintinline{text}{+}'. L'ennui est qu'elle offre aussi
de nombreux mécansimes de protection tel que la macro \mintinline{text}{panic!}.
Tous ces mécanismes réprésentent une place considérable dans un programme Rust
compilé statiquement. Une solution a finalement été trouvé et détaillée dans le
chapitre \ref{sec:user:compil} mais avant de comprendre que les programmes utilisateurs
ne marchaient pas pour cette raison, il a fallu énormément investiguer.

\subsubsection{Passage à la pagination}
Le passage de la gestion mémoire par segmentation à la pagination a été l'origine
de quelques difficultés. Peu de documentation est disponible à ce sujet sur internet.
Des exemple peuvent être trouvés mais aucun n'a fonctionné dans le cas de notre
\acrshort{os}. Le plus compliqué a été de déplacer le \textit{kernel} à la fin
de la \acrshort{ram}. Ensuite il a fallu refaire la gestion des applications
utilisateurs en utilisant la pagination. Il n'y a aucune information implicite
sur l'utilisation du champ \mintinline{text}{cr3} du \acrshort{tss} dans la documentation
d'Intel. Tout a été trouvé de manière empirique en regardant le comportement
du \textit{kernel} lorsque des paramètres sont changés. De plus, quand il y a
un problème au niveau de la pagination, le processeur lève en général l'exception
\textit{Triple Fault} qui a pour conséquence de faire redémarrer QEMU. Il est
donc plus compliqué de corriger les erreurs car il n'y a plus l'information de
la ligne de code qui a provoqué l'exception.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\subsection{Améliorations possibles}
Actuellement, toutes les fonctionnalités décrites dans ce document marchent
parfaitement. Il n'a malheureusement pas été possible (faute de temps), de démontrer
ces fonctionnalités avec une application utilisateur plus poussée. Une démo a
été développée utilisant l'intégralité des appels systèmes du \textit{kernel}
mais elle ne fait qu'afficher du texte à l'écran. Par exemple, il pourrait être
intéressant de développer un jeu. Ce jeu pourrait avoir un affichage en mode texte
avec l'implémentation d'une librairie comme \mintinline{text}{curses} en C ou bien
un affichage pixel par pixel en changeant le mode de l'écran \acrshort{vga}. \\

Plusieurs améliorations sont aussi possibles au niveau de l'implémentation des
tâches utilisateurs. Une première amélioration pourrait être de gérer les
librairies dans le système. Dans le cas de notre \acrshort{os}, on pourrait
ainsi avoir la librairie système stockée dans le système de fichiers et les
applications utilisateurs feraient appel à cette dernière plutôt que d'être
chacun compilé statiquement. Cela implique d'avoir des pages partagées entre plusieurs
tâches. Une autre amélioration possible pourrait être la gestion de la concurrence
afin d'exécuter plusieurs tâches en parallèle. A l'heure actuelle, quand plusieurs
tâches sont exécutées en même temps, elles sont impriquées. Une tâche en appelle
une autre et elle reprend son exécution quand la nouvelle tâche a fini la sienne. \\

Il pourrait aussi être intéressant d'améliorer le système de fichiers. Pour le
moment le système de fichiers est très basique. Tous les fichiers sont ajoutés
à la racine, il n'est pas possible d'écrire, il y a une limite de stockage
de fichiers très basse. Toutes ces fonctionnalités actuellement non disponibles
pourraient être rajoutées. On pourrait même imaginer un autre système de fichiers
que \acrshort{fat} qui serait plus moderne.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Conclusion}
Ce projet avait plusieurs objectifs. Il fallait dans un premier temps prendre
en main le langage de programmation Rust afin de développer un système d'exploitation
\textit{bare metal}. Ce projet reposait beaucoup sur le cours de programmation
système avancée de l'orientation logiciels et systèmes complexes à hepia. Etant
en orientation matérielle, il a fallu étudier ce sujet en plus du langage Rust.
Ce projet a donc été pour une grande partie un travail de recherche sur le Rust
et sur la conception d'un système d'exploitation pour processeurs Intel 32 bits. \\

Un système d'exploitation simple a finalement été développé. Il est intégralement
en Rust (à l'exception de certaines fonctions en assembleur). Beaucoup
de code a du être mis en \mintinline{text}{unsafe}. Il n'a pas été possible de faire
autrement car nous sommes obligés de faire des manipulations mémoires considérées
\mintinline{text}{unsafe} par le compilateur de Rust. Le mot-clé \mintinline{text}{unsafe}
a tout de même été utilisé avec parcimonie car un des plus gros avantages de Rust
est son compilateur. Mettre l'intégralité du code \mintinline{text}{unsafe} reviendrait
à coder en C. Les objectifs internes à l'implémentation du système d'exploitation
ont aussi été atteints. La gestion de la mémoire par pagination est fonctionnelle. 
Il est aussi possible d'allouer de la mémoire dynamiquement en tant qu'utilisateur
avec les fonctions \mintinline{rust}{malloc} et \mintinline{rust}{free} de la
librairie système implémentée. Des périphériques sont utilisés (affichage \acrshort{vga},
\textit{timer} et clavier). Ils sont gérés grâce aux ports d'entrées/sorties
et aux interruptions. Un mécanisme de commutation de tâches a été implémenté
permettant d'exécuter des applications utilisateurs. Par ailleurs, un shell
a été développé rendant l'\acrshort{os} plus intéractif. \\

Ce projet a aussi permis d'examiner le langage Rust. Il est vrai que c'est un
langage très performant et sécurisé. Il a beaucoup d'avantages par rapport
au C et ses inconvénients sont présents surtout car il est encore jeune. Il est
fort possible que ce langage remplace un jour le C pour la programmation système
et même pour la conception d'\acrshort{os}. Le système d'exploitation Redox est
d'ailleurs entièrement fait en Rust \cite{ref31}. Il est tout de même difficile
de voir un jour Rust remplacer complètement le C. En effet, il semble encore trop
haut niveau pour les systèmes embarqués. \\

En conclusion, je dirais que ce projet a été très instructif. N'ayant pas fait le
cours de programmation système avancée, j'étais très motivé à l'idée de réaliser
ce travail. La programmation système est un domaine qui m'intéresse beaucoup
car il fait le lien entre le matériel et le logiciel. De plus, j'ai eu l'occasion
d'apprendre un nouveau langage : le Rust. Je pense que ce langage a de l'avenir
et que connaitre ses spécificités pourra être bénéfique pour plus tard. Je serais
aussi curieux de voir ce qu'il pourrait donner dans la programmation pour systèmes
embarqués.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section*{Références}
\addcontentsline{toc}{section}{Références}
\nocite{*}
\bibliographystyle{unsrt}
\bibliography{biblio}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section*{Annexe A : Code source}
\addcontentsline{toc}{section}{Annexe A : Code source}
Le code source du projet est disponible en annexe au format papier ou au format
électronique à l'adresse \url{https://github.com/orpheeantoniadis/RustOS}.

\newpage
\section*{Annexe B : Installation}
\addcontentsline{toc}{section}{Annexe B : Installation}
Ci dessous, les étapes d'installation du système d'exploitation. Toutes les
commandes sont à exécuter dans un shell d'une distribution Linux. \\

\paragraph{Configuration de Linux} \mbox{} \\
\begin{minted}[tabsize=4,frame=single,bgcolor=bg]{shell}
sudo apt-get install git curl nasm qemu
\end{minted}

\paragraph{Configuration de Rust} \mbox{} \\
\begin{minted}[tabsize=4,frame=single,bgcolor=bg]{shell}
curl https://sh.rustup.rs -sSf | sh
echo source $HOME/.cargo/env >> ~/.bashrc
rustup override add nightly
cargo install xargo
rustup component add rust-src
\end{minted}

\paragraph{Compilation} \mbox{} \\
\begin{minted}[tabsize=4,frame=single,bgcolor=bg]{shell}
git clone git@github.com:orpheeantoniadis/RustOS.git
cd RustOS
make build
\end{minted}

\paragraph{Exécution} \mbox{} \\
\begin{minted}[tabsize=4,frame=single,bgcolor=bg]{shell}
make run
\end{minted}

\paragraph{Documentation} \mbox{} \\
\begin{minted}[tabsize=4,frame=single,bgcolor=bg]{shell}
make doc
\end{minted}

\end{document}
