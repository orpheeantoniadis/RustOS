%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Introduction}
Rust est un langage de programmation système développé par Mozilla et conçu pour
être sécurisé. Le but de Rust est de remplacer les autres langages système comme
le C ou le C++. Les trois caractéristiques mises en valeur par l'équipe de Rust
sont la rapidité, la sécurité (prévient des erreurs de segmentation) et la concurrence
(garantit la sûreté entre \textit{threads}) \cite{ref27}. La première version
de Rust est sortie en janvier 2012 \cite{ref28}. Ce langage est donc très récent
et emprunte beaucoup de concepts de programmation à d'autres langages. Une première
partie de ce projet a été un travail de recherche afin d'apprendre ce langage.
Beaucoup de documentation est disponible sur le site de Rust dont le livre
de Rust, \textit{The Rust Programming Language}, sorti en deux éditions différentes
(\href{https://doc.rust-lang.org/book/first-edition}{\textit{First Edition}} et
\href{https://doc.rust-lang.org/book/second-edition}{\textit{Second Edition}}).
Ce livre est disponible en ligne et est une très bonne introduction au langage.
Il donne beaucoup d'exemples et permet de comprendre rapidement le fonctionnement de
Rust.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Installation et compilation}
\subsubsection{Installation de Rust}
Rust est distribué sous trois versions différentes. La version \textit{stable},
la version \textit{beta} et la version \textit{nightly}. La version \textit{nightly}
possède plus de fonctionnalités mais sa stabilité n'est pas garantie. Cette version
a été utilisée pendant le développement du projet. Rustup est un gestionnaire de
version du langage Rust. Pour installer Rust ainsi que cet utilitaire, il faut
exécuter la commande suivante \cite{ref2}.

\begin{shellcode}
$ curl https://sh.rustup.rs -sSf | sh
\end{shellcode}

Le gestionnaire de version rustup peut maintenant être utilisé pour changer la
version de Rust. Notre système d'exploitation utilise la version \textit{nightly}
de Rust, la commande suivante doit donc être exécutée.

\begin{shellcode}
$ rustup override add nightly
\end{shellcode}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Compilation d'un programme en Rust}
\label{rust_compil}
Le compilateur de Rust est rustc. Il est installé automatiquement lors de
l'installation de Rust. Prenons le programme ci-dessous qui est contenu
dans le fichier \mintinline{text}{hello.rs}.

\begin{code}
\begin{rustcode}
fn main() {
    let hello = "Hello world!";
    println!("{}", hello);
}
\end{rustcode}
\caption{Premier programme en Rust}
\label{lst:rust:hello}
\end{code} \bigbreak

Le mot-clé \mintinline{rust}{let} indique qu'une variable est déclarée. On remarque
qu'aucun type n'est donné dans la déclaration. L'inférence de types est l'un des
nombreux concepts utilisés par Rust. L'équivalent en C serait
\mintinline{c}{char hello[] = "Hello world!"}. Le programme affiche ensuite cette
variable sur la sortie standard en utilisant la macro \mintinline{rust}{println!}.
Les macros seront vues plus en détail dans la suite de ce document. On peut les
distinguer des fonctions par la manière dont elles sont appelées. L'appel d'une
macro se fait avec son nom suivi d'un '!'. Ce programme affiche donc "Hello world!"
sur la sortie standard. Pour générer un exécutable à partir de ce code, le compilateur
de Rust, rustc peut être utilisé avec la commande \mintinline{shell}{rustc hello.rs}.
Cette méthode fonctionne bien lorsqu'on ne veut compiler qu'un seul fichier
comme dans cet exemple. Cela devient vite compliqué lorsqu'il faut gérer des dépendances
entre plusieurs fichiers et utiliser des librairies externes. Heureusement,
une solution existe pour résoudre ce problème. Rust fournit un gestionnaire
de paquets nommé Cargo.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Cargo}
Le gestionnaire de paquets de Rust, Cargo, peut non seulement gérer les dépendances
d'un projet mais s'occupe aussi de sa compilation \cite{ref3}. Cargo est installé
en même temps que Rust, il n'y a donc pas de manipulations supplémentaires à faire
pour l'utiliser. Cargo fonctionne à l'aide d'un fichier de configuration du projet
au format \acrshort{toml}. Ce fichier doit être appelé \mintinline{text}{Cargo.toml}.
Le contenu du fichier \mintinline{text}{Cargo.toml} ressemble généralement
au code dans le \textit{listing} \ref{lst:rust:cargotoml} \cite{ref2}.

\begin{code}
\begin{minted}[fontsize=\footnotesize,tabsize=4,frame=single,linenos]{text}
[package]
name = "hello"
version = "0.1.0"
authors = ["Your Name <you@example.com>"]

[dependencies]
\end{minted}
\caption{Contenu du fichier \mintinline{text}{Cargo.toml}}
\label{lst:rust:cargotoml}
\end{code} \bigbreak

Cargo compile et gère automatiquement les dépendances de tous les fichiers contenus
dans le répertoire \mintinline{text}{src}. Si on reprend l'exemple du \textit{listing}
\ref{lst:rust:hello}, un projet utilisant Cargo aurait l'arborescence suivante. \\

\dirtree{%
.1 \mintinline{text}{hello}.
.2 \mintinline{text}{Cargo.toml}.
.2 \mintinline{text}{src}.
.3 \mintinline{text}{main.rs}.
} \bigbreak

Des dépendances externes (appelées \textit{crates}) peuvent être utilisées dans
le projet en les ajoutant dans le fichier \acrshort{toml}, sous la section \textit{dependencies}.
Une \textit{crate} peut être en local sur la machine hôte ou être disponible en ligne
sur \href{https://crates.io}{Crates.io}. Ce site sert de registre pour toutes les
librairies Rust développées par la communauté. Cargo télécharge automatiquement
les dépendances depuis \href{https://crates.io}{Crates.io} \cite{ref2}. Pour compiler un projet,
rustc n'a plus a être utilisé. Cargo fait appel au compilateur
de rust lui même. Pour demander à cargo de compiler le projet il faut exécuter
la commande \mintinline{shell}{cargo build}. Si le projet est un exécutable,
il est lancé avec la commande \mintinline{shell}{cargo run}. Notre système
d'exploitation utilise un gestionnaire de paquets basé sur Cargo. Celui-ci
se nomme Xargo. Il peut être installé directement depuis Cargo en utilisant
la commande \mintinline{shell}{cargo install xargo}. Xargo est fait pour compiler
un projet Rust dans un environnement \textit{bare metal}. Dans ce type d'environnement
il n'y a aucune librairie système étant donné que nous créons nous même le système.
Le code doit donc être compilé sans dépendances à la librairie standard. Rust a tout
de même besoin d'une base pour être compilé. Cette base est fournie par la librairie
\mintinline{rust}{core}. Xargo lie la librairie \mintinline{rust}{core} au projet
automatiquement contrairement à Cargo \cite{ref8}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Compilation croisée}
Dans le cadre du projet, le code Rust a du être compilé pour une architecture
Intel 32-bits (\acrshort{IA-32}). On parle ici de compilation croisée
car une machine hôte (\textit{host} en anglais) compile du code pour une
machine cible (\textit{target} en anglais). Quand on fait de la compilation
croisée, on se réfère à des caractéristiques nommées \textit{triple}. Un \textit{triple}
a généralement le format architecture-vendeur-système-\acrshort{abi}. Par exemple
pour \textit{cross-compiler} pour une machine Apple, le format du \textit{triple}
est x86$\_$64-apple-darwin. A noter que l'\acrshort{abi} n'est pas spécifiée.
Rust propose un système natif de compilation croisée pour de nombreuses cibles.
Ceci peut se faire avec le compilateur rustc ou bien avec Cargo en spécifiant
la machine cible avec l'option \mintinline{shell}{--target=} suivie du
\textit{target triple}. Il est possible de configurer son propre \textit{target triple}
dans un fichier \acrshort{json} placé à la racine du projet. Dans ce cas, il
faut donner le nom du fichier (sans l'extension .json) à l'option de Cargo.
Dans notre \acrshort{os}, le nom du fichier est \mintinline{text}{i386-rust_os.json}.
Notre projet a donc l'arborescence suivante. \\

\dirtree{%
.1 \mintinline{text}{kernel}.
.2 \mintinline{text}{Cargo.toml}.
.2 \mintinline{text}{i386-rust_os.json}
.2 \mintinline{text}{src}.
.3 \mintinline{text}{kernel.rs}.
} \bigbreak

Le fichier \mintinline{text}{i386-rust_os.json} configure la machine cible
pour l'architecture i386 (\acrshort{IA-32}) et sans système d'exploitation.
Ci-dessous, le contenu de ce fichier. \\

\begin{code}
\begin{minted}[fontsize=\footnotesize,tabsize=4,frame=single,linenos]{text}
{
  "llvm-target": "i386-unknown-none",
  "data-layout": "e-m:e-p:32:32-f64:32:64-f80:32-n8:16:32-S128",
  "linker-flavor": "gcc",
  "target-endian": "little",
  "target-pointer-width": "32",
  "target-c-int-width": "32",
  "arch": "x86",
  "os": "none",
  "disable-redzone": true,
  "features": "-mmx,-sse,+soft-float",
  "panic-strategy": "abort"
}
\end{minted}
\caption{Contenu du fichier \mintinline{text}{i386-rust_os.json}}
\label{lst:rust:target}
\end{code} \bigbreak

Tous les champs du \textit{target triple} sont décrits dans la documentation de
Rust \cite{ref4}. Le contenu de ce fichier est inspiré de plusieurs \textit{target triples}
trouvés sur internet. L'un dans une \textit{issue} du \textit{repository}
de Rust sur GitHub \cite{ref5} et l'autre dans un blog parlant de l'écriture
d'un système d'exploitation en Rust \cite{ref8}. La compilation croisée de notre
\textit{kernel} peut maintenant se faire avec la commande
\mintinline{shell}{xargo build --target=i386-rust_os}. A noter qu'il existe un
\textit{bug} avec l'option \mintinline{text}{target} quand on utilise notre propre
\textit{target triple} \cite{ref7}. Pour ne pas qu'il se produise, il faut indiquer
le chemin d'accès au répertoire contenant le fichier \acrshort{json} en utilisant
la variable d'environnement \mintinline{shell}{RUST_TARGET_PATH}. La commande finale
pour compiler le projet est la suivante :

\begin{shellcode}
$ RUST_TARGET_PATH=$(pwd) xargo build --target i386-rust_os
\end{shellcode}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Bases du langage}
\subsubsection{Commentaires}
Les commentaires en Rust ont la même syntaxe que les commentaires en C. Le \textit{listing}
\ref{lst:rust:comments} montre les différents types de commentaire.

\begin{code}
\begin{rustcode}
// Commentaire sur une seule ligne

/* Commentaire sur
   plusieurs lignes */
\end{rustcode}
\caption{Commentaires en Rust}
\label{lst:rust:comments}
\end{code} \bigbreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Variables et mutabilité}
Les variables en Rust sont toutes constantes par défaut. Le code du \textit{listing}
\ref{lst:rust:var1} ne pourra pas compiler.

\begin{code}
\begin{rustcode}
let x = 0;
x += 1; // Erreur !
\end{rustcode}
\caption{Exemple de variable immutable}
\label{lst:rust:var1}
\end{code} \bigbreak

Pour rendre une variable mutable, le mot-clé \mintinline{rust}{mut} doit être utilisé.
Le code du \textit{listing} \ref{lst:rust:var2} corrige celui du \textit{listing}
\ref{lst:rust:var1}.

\begin{code}
\begin{rustcode}
let mut x = 0;
x += 1; // Plus d'erreur, la variable x est mutable
\end{rustcode}
\caption{Exemple de variable mutable}
\label{lst:rust:var2}
\end{code} \bigbreak

Une variable peut aussi être réécrite. On appelle ça le \textit{shadowing}.

\begin{code}
\begin{rustcode}
let x = 0;
let x = "zero";
\end{rustcode}
\caption{Exemple de \textit{shadowing}}
\label{lst:rust:var3}
\end{code} \bigbreak

Le mot-clé \mintinline{rust}{let} sans \mintinline{rust}{mut} peut faire penser
aux constantes en C. Rust permet aussi de déclarer des constantes avec le mot-clé
\mintinline{rust}{const}. Lors d'une déclaration de constante en Rust, le type
de la variable doit être donné ainsi que sa valeur qui doit être constante (valeur
fixée à la compilation et non au \textit{runtime}). Une constante est déclarée
globalement. Pour déclarer une variable globalement il faut utiliser le mot-clé
\mintinline{rust}{static}. Comme pour les constantes, quand une variable est déclarée
statiquement, son type et sa valeur doivent être déterminés à la compilation.

\begin{code}
\begin{rustcode}
const KHEAP_SIZE        : usize = 0x1000000;
static mut KHEAP_ADDR   : u32   = 0;
\end{rustcode}
\caption{Déclaration d'une constante et d'une variable statique}
\label{lst:rust:var4}
\end{code} \bigbreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Fonctions et macros}
Les fonctions en Rust sont semblables aux fonctions en C. Leur déclaration se fait
avec le mot-clé \mintinline{rust}{fn}. Les macros de Rust reprennent le concept
des macros du langage C. La particularité d'une macro par rapport à une fonction
est qu'une macro va être remplacée à la compilation par le code qu'elle contient.
De plus, le nombre d'arguments d'une macro n'est pas fixe. Une macro fonctionne
par motifs. Prenons pour exemple l'implémentation de la macro \mintinline{rust}{println!}. \\

\begin{code}
\begin{rustcode}
macro_rules! println {
    () => (print!("\n"));
    ($fmt:expr) => (print!(concat!($fmt, "\n")));
    ($fmt:expr, $($arg:tt)*) => (print!(concat!($fmt, "\n"), $($arg)*));
}
\end{rustcode}
\caption{Code source de la macro \mintinline{rust}{println!}}
\label{lst:rust:macro}
\end{code} \bigbreak

Cette macro a trois motifs différents. Si aucun argument n'est donné à la macro,
le premier motif va être utilisé. Nous pouvons voir qu'il affiche simplement
un saut de ligne avec la macro \mintinline{rust}{print!}. Dans une macro, la partie gauche
contient un ensemble de symboles et la partie droite l'action à effectuer avec
les symboles. Prenons maintenant la deuxième ligne de cette macro. Pour que
ce motif soit appelé, une expression doit être donnée à la macro. Le symbole
de cette expression est \mintinline{rust}{$fmt} (comme le nom d'un argument dans
une fonction, le symbole d'une macro est arbitraire). Ce \textit{pattern} est
appelé quand par exemple nous ne voulons afficher qu'une chaîne de caractères
non formatée (\mintinline{rust}{println!("Hello")}). La dernière ligne de cette
macro représente le cas où un ou plusieurs arguments suplémentaires sont donnés
à la macro. Dans cet exemple, c'est le cas où on veut formater la chaîne de caractères
comme dans le \textit{listing} \ref{lst:rust:hello}. Quand un symbole est suivi
d'un '*', cela veut dire qu'il peut être répété zéro ou plus de fois \cite{ref1}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Structures de contrôle}
Le langage Rust propose les mêmes structures de contrôle que le langage C.
Une condition se fait avec l'expression \mintinline{rust}{if} et du code
peut être répété avec les expressions  \mintinline{rust}{for},  \mintinline{rust}{while}
et  \mintinline{rust}{loop}. Rust possède également une structure de contrôle pour
faire du \textit{pattern matching}. Elle est utilisée avec l'expression \mintinline{rust}{match}.
A noter qu'on parle ici d'expression. Une expression peut être utilisée dans la
déclaration d'une variable. Le code suivant est donc possible \cite{ref2}. \\

\begin{code}
\begin{rustcode}
let condition = true;
let number = if condition {
    5
} else {
    6
};
\end{rustcode}
\caption{Utiliser l'expression \mintinline{rust}{if} dans une déclaration de variable}
\label{lst:rust:if}
\end{code} \bigbreak

Dans cet exemple, la variable \mintinline{rust}{number} sera initialisée à la
valeur 5. \newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Structures de données}
Rust donne aussi accès à des structures de données, semblables aux structures
C dans leur déclaration mais néanmoins différentes. Ces structures peuvent
implémenter des méthodes. On peut donc aussi les comparer aux classes en Java.
Ci-dessous, une structure implémentant deux méthodes.

\begin{code}
\begin{rustcode}
#[derive(Clone)]
#[repr(C, align(4096))]
pub struct PageTable {
    pub entries: [u32;0x400]
}
impl PageTable {
    fn null() -> PageTable {
        PageTable {
            entries: [0;0x400]
        }
    }
    pub fn as_ptr(&mut self) -> u32 {
        self as *const PageTable as u32
    }
}
\end{rustcode}
\caption{Exemple de structure en Rust}
\label{lst:rust:struct}
\end{code} \bigbreak

Ici, la structure \mintinline{rust}{PageTable} ne contient qu'un seul champs
mais il peut y en avoir plus. Les deux lignes commençant par un '\mintinline{text}{#}'
sont des attributs appliqués à la structure \cite{ref2}. Le premier attribut permet
d'inclure automatiquement les fonctionnalités du trait \mintinline{rust}{Clone}
à notre structure. Le deuxième attribut indique que cette structure doit être représentée
comme en C dans la mémoire et être alignée sur 4096 octets. L'implémentation de
méthodes pour une structure se fait avec le mot-clé \mintinline{rust}{impl}. La
première méthode est un constructeur renvoyant simplement une structure initialisée
avec des zéros. La deuxième méthode peut être appliquée à une structure, elle
renvoie l'adresse de cette dernière. Le \textit{listing} \ref{lst:rust:struct:methods}
montre comment appeler ces méthodes.

\begin{code}
\begin{rustcode}
let table = PageTable::null();
let table_addr = table.as_ptr();
\end{rustcode}
\caption{Appels aux méthodes d'une structure}
\label{lst:rust:struct:methods}
\end{code} \bigbreak

A noter que le mot-clé \mintinline{rust}{pub} est utilisé à trois reprises dans
le \textit{listing} \ref{lst:rust:struct}. Ce mot-clé contrôle la visibilité de
la variable, la fonction, le champ ou la structure qui lui est associé. Il fait
le contraire du mot-clé \mintinline{java}{private} en Java (de base tout est privé
dans un fichier Rust) \cite{ref2}. En plus des structures, Rust propose aussi
les énumérations ou \mintinline{rust}{enum}. Un \mintinline{rust}{enum} permet
de définir un type en énumérant toutes ses valeurs possibles \cite{ref2}. Le
\textit{listing} \ref{lst:rust:enum} donne un exemple d'\mintinline{rust}{enum}
dont chaque valeur est sur huit bits.

\begin{code}
\begin{rustcode}
#[repr(u8)]
pub enum Color {
    Black = 0x0,
    White = 0xf
}
\end{rustcode}
\caption{Déclaration d'un \mintinline{rust}{enum}}
\label{lst:rust:enum}
\end{code} \bigbreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Spécificités du langage}
\subsubsection{\textit{Ownership} et références}
L'\textit{Ownership} est la fonctionnalité de Rust lui permettant de garantir la
sécurité au niveau de la mémoire. Elle est décrite dans le livre de Rust comme
la fonctionnalité fondamentale du langage. Chaque valeur en Rust est liée à une
variable nommée propriétaire (\textit{owner} en anglais). Une valeur
ne peut avoir qu'un seul propriétaire à la fois. Quand on sort de la portée de
la variable, la valeur n'est plus accessible \cite{ref2}. Prenons pour exemple
la structure \mintinline{rust}{PageTable} décrite plus haut. Le code suivant
provoquera une erreur.

\begin{code}
\begin{rustcode}
let table1 = PageTable::null();
let table2 = table1;              // table2 prend l'ownership de la valeur de table1
let table_addr = table1.as_ptr(); // Erreur ! table1 n'a plus de valeur
\end{rustcode}
\caption{Changement d'\textit{ownership}}
\label{lst:rust:ownership}
\end{code} \bigbreak

Pour corriger cette erreur, il faut copier la valeur de la variable \mintinline{rust}{table1}
dans \mintinline{rust}{table2} en utilisant la méthode \mintinline{rust}{clone()}.
C'est pour cette raison que nous avons spécifié l'utilisation des fonctionnalités
du trait \mintinline{rust}{Clone} lors de la déclaration de la structure dans
le \textit{listing} \ref{lst:rust:struct}. Notre variable peut être stockée sur
la pile car sa taille est connue à la compilation. Un autre trait
offert par Rust peut être utilisé ici pour copier sa valeur. C'est le trait
\mintinline{rust}{Copy}. Les fonctionnalités de ce trait
peuvent être rajoutées à une structure stockée dans la pile en l'ajoutant à l'attribut
\mintinline{rust}{derive}. Grâce à ce trait, il n'y a pas besoin
d'appeler la méthode \mintinline{rust}{clone()} pour copier la valeur. La copie
est faite automatiquement. Pour ne pas perdre l'\textit{Ownership} lors du passage
d'une variable à une fonction, une référence à cette variable peut être donnée
à la place (opérateurs \mintinline{rust}{&} et \mintinline{rust}{&mut}) \cite{ref2}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Traits}
Un trait en Rust ajoute des fonctionnalités à un type.
Ces fonctionnalités peuvent être partagées entre plusieurs types. Il existe des
traits déjà disponibles dans le code de Rust comme ceux
utilisés précédemment (\mintinline{rust}{Clone} et \mintinline{rust}{Copy}).
Un trait est déclaré avec le mot-clé \mintinline{rust}{trait}. Pour implémenter
un trait dans une structure, le mot-clé \mintinline{rust}{impl} peut aussi
être utilisé. Reprenons la structure \mintinline{rust}{PageTable} du \textit{listing}
\ref{lst:rust:struct}. Cette structure contient un tableau et il serait pratique
de pouvoir récupérer un élément de ce tableau directement en faisant
\mintinline{rust}{table[i]} avec \mintinline{rust}{i} contenant l'indice du tableau.
Actuellement, ce n'est pas possible, il faut faire \mintinline{rust}{table.entries[i]}.
Les traits \mintinline{rust}{Index} et \mintinline{rust}{IndexMut} permettent
ce comportement. Le \textit{listing} \ref{lst:rust:traits} montre comment implémenter
ces traits dans le cas de \mintinline{rust}{PageTable}.

\begin{code}
\begin{rustcode}
impl Index<usize> for PageTable {
    type Output = u32;
    fn index(&self, index: usize) -> &u32 {
        &self.entries[index]
    }
}
impl IndexMut<usize> for PageTable {
    fn index_mut(&mut self, index: usize) -> &mut u32 {
        &mut self.entries[index]
    }
}
\end{rustcode}
\caption{Implémentation de traits pour une structure}
\label{lst:rust:traits}
\end{code}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Gestion des erreurs}
Rust possède tout un mécanisme de gestion des erreurs. Les erreurs sont séparées
en deux catégories. Les erreurs récupérables et non récupérables. Quand une erreur
est récupérable, le type \mintinline{rust}{Result<T, E>} est utilisé pour gérer
l'erreur (en général dans une expression \mintinline{rust}{match}). Dans le cas
contraire, la macro \mintinline{rust}{panic!} est appelée. Par défaut quand, un
programme panique, Rust réinitialise la pile et nettoie la mémoire avant de quitter.
Ce comportement peut être annulé en rajoutant la section du \textit{listing}
\ref{lst:rust:errors:abort} \cite{ref2}.

\begin{code}
\begin{minted}[fontsize=\footnotesize,tabsize=4,frame=single,linenos]{text}
[profile.release]
panic = 'abort'
\end{minted}
\caption{Section à ajouter au fichier \acrshort{toml}}
\label{lst:rust:errors:abort}
\end{code} \bigbreak

\subsubsection{Tests unitaires}
Rust offre tout un mécanisme de tests unitaires. Ce mécanisme est utilisé avec
Cargo en exécutant la commande \mintinline{shell}{cargo test}. Quand cette
commande est exécutée, Cargo cherche le module \mintinline{rust}{tests} du projet.
Un module en Rust contient des variables, des fonctions et des structures. Il permet
de diviser le code en parties plus petites. Un module peut être dans le fichier
principal du projet ou dans un fichier différent. Dans le cas des tests unitaires
un module basique ressemblerait à celui décrit dans le \textit{listing} suivant.

\begin{code}
\begin{rustcode}
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
\end{rustcode}
\caption{Module \mintinline{rust}{tests}}
\label{lst:rust:tests}
\end{code} \bigbreak

L'attribut \mintinline{rust}{#[cfg(test)]} dit à Rust de ne compiler le code
que si \mintinline{text}{cargo test} est exécuté. Lors de l'exécution des tests
unitaires, Cargo appelle toutes les fonctions préfixées de l'attribut \mintinline{rust}{test}
\cite{ref2}. Malheureusement, les tests unitaires n'ont pas pu être beaucoup utilisés
dans le cadre de ce projet car ils sont exécutés sur la machine hôte. Notre système
d'exploitation est compilé sur la machine hôte mais est exécuté sur une autre
machine (dans notre cas une machine virtuelle, QEMU). Il n'est donc pas possible
d'utiliser ce mécanisme de tests pour tester les différentes parties du système.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{\textit{Unsafe} Rust}
Nous avons vu que Rust garantit la sécurité de la mémoire à la compilation.
Le compilateur ne nous laisse par exemple pas déréférencer un pointeur, modifier
une variable statique ou encore appeler du code d'un autre langage.
Le problème est que nous utilisons Rust dans le cadre de la programmation système.
Rust est utilisé dans ce projet pour créer un système d'exploitation. Il est nécéssaire
d'accéder à la mémoire sans restrictions et d'appeler du code assembleur. Rust donne
la possibilité de supprimer la protection du compilateur avec le mot-clé
\mintinline{rust}{unsafe}. Quand un code est \mintinline{rust}{unsafe}, plus aucune
protection n'est appliquée. Il est donc très déconseillé de l'utiliser. En effet,
en utilisant du code \mintinline{rust}{unsafe}, on perd beaucoup d'avantages de Rust
\cite{ref2}.